"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScProvider = void 0;
Object.defineProperty(exports, "WellKnownChain", {
  enumerable: true,
  get: function () {
    return _connect.WellKnownChain;
  }
});

var _connect = require("@substrate/connect");

var _eventemitter = _interopRequireDefault(require("eventemitter3"));

var _util = require("@polkadot/util");

var _index = require("../coder/index.cjs");

var _Health = require("./Health.cjs");

// Copyright 2017-2022 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0
// These methods have been taken from:
// https://github.com/paritytech/smoldot/blob/17425040ddda47d539556eeaf62b88c4240d1d42/src/json_rpc/methods.rs#L338-L462
// It's important to take into account that smoldot is adding support to the new
// json-rpc-interface https://paritytech.github.io/json-rpc-interface-spec/
// However, at the moment this list only includes methods that belong to the "old" API
const subscriptionUnsubscriptionMethods = new Map([['author_submitAndWatchExtrinsic', 'author_unwatchExtrinsic'], ['chain_subscribeAllHeads', 'chain_unsubscribeAllHeads'], ['chain_subscribeFinalizedHeads', 'chain_unsubscribeFinalizedHeads'], ['chain_subscribeFinalisedHeads', 'chain_subscribeFinalisedHeads'], ['chain_subscribeNewHeads', 'chain_unsubscribeNewHeads'], ['chain_subscribeNewHead', 'chain_unsubscribeNewHead'], ['chain_subscribeRuntimeVersion', 'chain_unsubscribeRuntimeVersion'], ['subscribe_newHead', 'unsubscribe_newHead'], ['state_subscribeRuntimeVersion', 'state_unsubscribeRuntimeVersion'], ['state_subscribeStorage', 'state_unsubscribeStorage']]);
const wellKnownChains = new Set(Object.values(_connect.WellKnownChain));
const scClients = new WeakMap();

class ScProvider {
  #coder = new _index.RpcCoder();
  #spec;
  #sharedSandbox;
  #subscriptions = new Map();
  #requests = new Map();
  #eventemitter = new _eventemitter.default();
  #chain = null;
  #isChainReady = false;

  constructor(spec, sharedSandbox) {
    this.#spec = spec;
    this.#sharedSandbox = sharedSandbox;
  }

  get hasSubscriptions() {
    // Indicates that subscriptions are supported
    return true;
  }

  get isConnected() {
    return !!this.#chain && this.#isChainReady;
  }

  clone() {
    throw new Error('clone() is not supported.');
  }

  async connect() {
    (0, _util.assert)(!this.isConnected, 'Already connected!'); // it could happen that after emitting `disconnected` due to the fact taht
    // smoldot is syncing, the consumer tries to reconnect after a certain amount
    // of time... In which case we want to make sure that we don't create a new
    // chain.

    if (this.#chain) {
      await this.#chain;
      return;
    }

    if (this.#sharedSandbox && !this.#sharedSandbox.isConnected) {
      await this.#sharedSandbox.connect();
    }

    const client = this.#sharedSandbox ? scClients.get(this.#sharedSandbox) : (0, _connect.createScClient)();
    (0, _util.assert)(client, 'Unkown ScProvider!');
    scClients.set(this, client);
    const hc = (0, _Health.healthChecker)();

    const onResponse = res => {
      var _response$params, _this$subscriptions$g;

      const hcRes = hc.responsePassThrough(res);

      if (!hcRes) {
        return;
      }

      const response = JSON.parse(hcRes);
      let decodedResponse;

      try {
        decodedResponse = this.#coder.decodeResponse(response);
      } catch (e) {
        decodedResponse = e;
      } // It's not a subscription message, but rather a standar RPC response


      if (((_response$params = response.params) === null || _response$params === void 0 ? void 0 : _response$params.subscription) === undefined || !response.method) {
        var _this$requests$get;

        return (_this$requests$get = this.#requests.get(response.id)) === null || _this$requests$get === void 0 ? void 0 : _this$requests$get(decodedResponse);
      } // We are dealing with a subscription message


      const subscriptionId = `${response.method}::${response.params.subscription}`;
      const callback = (_this$subscriptions$g = this.#subscriptions.get(subscriptionId)) === null || _this$subscriptions$g === void 0 ? void 0 : _this$subscriptions$g[0];
      callback === null || callback === void 0 ? void 0 : callback(decodedResponse);
    };

    const addChain = wellKnownChains.has(this.#spec) ? client.addWellKnownChain : client.addChain;
    this.#chain = addChain(this.#spec, onResponse).then(chain => {
      hc.setSendJsonRpc(chain.sendJsonRpc);
      this.#isChainReady = false;

      const cleanup = () => {
        // If there are any callbacks left, we have to reject/error them.
        // Otherwise, that would cause a memory leak.
        const disconnectionError = new Error('Disconnected');
        this.#requests.forEach(cb => cb(disconnectionError));
        this.#subscriptions.forEach(_ref => {
          let [cb] = _ref;
          return cb(disconnectionError);
        });
        this.#subscriptions.clear();
      };

      const staleSubscriptions = [];

      const killStaleSubscriptions = () => {
        if (staleSubscriptions.length === 0) {
          return;
        } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion


        const {
          id,
          unsubscribeMethod
        } = staleSubscriptions.pop(); // eslint-disable-next-line @typescript-eslint/no-floating-promises

        Promise.race([this.send(unsubscribeMethod, [id]).catch(Function.prototype), new Promise(resolve => setTimeout(resolve, 500))]).then(killStaleSubscriptions);
      };

      hc.start(health => {
        const isReady = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers); // if it's the same as before, then nothing has changed and we are done

        if (this.#isChainReady === isReady) {
          return;
        }

        this.#isChainReady = isReady;

        if (!isReady) {
          // If we've reached this point, that means that the chain used to be "ready"
          // and now we are about to emit `disconnected`.
          //
          // This will cause the PolkadotJs API think that the connection is
          // actually dead. In reality the smoldot chain is not dead, of course.
          // However, we have to cleanup all the existing callbacks because when
          // the smoldot chain stops syncing, then we will emit `connected` and
          // the PolkadotJs API will try to re-create the previous
          // subscriptions and requests. Although, now is not a good moment
          // to be sending unsubscription messages to the smoldot chain, we
          // should wait until is no longer syncing to send the unsubscription
          // messages from the stale subscriptions of the previous connection.
          //
          // That's why -before we perform the cleanup of `this.#subscriptions`-
          // we keep the necessary information that we will need later on to
          // kill the stale subscriptions.
          [...this.#subscriptions.values()].forEach(s => {
            staleSubscriptions.push(s[1]);
          });
          cleanup();
        } else {
          killStaleSubscriptions();
        }

        this.#eventemitter.emit(isReady ? 'connected' : 'disconnected');
      });
      return { ...chain,
        remove: () => {
          hc.stop();
          chain.remove();
          cleanup();
        },
        sendJsonRpc: hc.sendJsonRpc.bind(hc)
      };
    });

    try {
      await this.#chain;
    } catch (e) {
      this.#chain = null;
      this.#eventemitter.emit('error', e);
      throw e;
    }
  }

  async disconnect() {
    if (!this.#chain) {
      return;
    }

    const chain = await this.#chain;
    this.#chain = null;
    this.#isChainReady = false;

    try {
      chain.remove();
    } catch (_) {}

    this.#eventemitter.emit('disconnected');
  }

  on(type, sub) {
    // It's possible. Although, quite unlikely, that by the time that polkadot
    // subscribes to the `connected` event, the Provider is already connected.
    // In that case, we must emit to let the consumer know that we are connected.
    if (type === 'connected' && this.isConnected) {
      sub();
    }

    this.#eventemitter.on(type, sub);
    return () => {
      this.#eventemitter.removeListener(type, sub);
    };
  }

  async send(method, params) {
    (0, _util.assert)(this.isConnected, 'Provider is not connected'); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

    const chain = await this.#chain;
    const json = this.#coder.encodeJson(method, params);
    const id = this.#coder.getId();
    const result = new Promise((resolve, reject) => {
      this.#requests.set(id, response => {
        ((0, _util.isError)(response) ? reject : resolve)(response);
      });

      try {
        chain.sendJsonRpc(json);
      } catch (e) {
        this.#chain = null;

        try {
          chain.remove();
        } catch (_) {}

        this.#eventemitter.emit('error', e);
      }
    });

    try {
      return await result;
    } finally {
      // let's ensure that once the Promise is resolved/rejected, then we remove
      // remove its entry from the internal #requests
      this.#requests.delete(id);
    }
  }

  async subscribe(type, method, params, callback) {
    (0, _util.assert)(subscriptionUnsubscriptionMethods.has(method), `Unsupported subscribe method: ${method}`);
    const id = await this.send(method, params);
    const subscriptionId = `${type}::${id}`;

    const cb = response => {
      if (response instanceof Error) {
        callback(response, undefined);
      } else {
        callback(null, response);
      }
    }; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion


    const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);
    this.#subscriptions.set(subscriptionId, [cb, {
      id,
      unsubscribeMethod
    }]);
    return id;
  }

  unsubscribe(type, method, id) {
    (0, _util.assert)(this.isConnected, 'Provider is not connected');
    const subscriptionId = `${type}::${id}`;

    if (!this.#subscriptions.has(subscriptionId)) {
      return Promise.reject(new Error(`Unable to find active subscription=${subscriptionId}`));
    }

    this.#subscriptions.delete(subscriptionId);
    return this.send(method, [id]);
  }

}

exports.ScProvider = ScProvider;