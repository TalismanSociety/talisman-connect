"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__bridge = void 0;
exports.allocString = allocString;
exports.allocU8a = allocU8a;
exports.getInt32 = getInt32;
exports.getString = getString;
exports.getU8a = getU8a;
exports.getUint8 = getUint8;
exports.getWasm = getWasm;
exports.resultString = resultString;
exports.resultU8a = resultU8a;
exports.withWasm = withWasm;

var _util = require("@polkadot/util");

// Copyright 2019-2022 @polkadot/wasm-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0

/* eslint-disable @typescript-eslint/no-non-null-assertion */
const __bridge = {
  cachegetInt32: null,
  cachegetUint8: null,
  type: 'wasm',
  wasm: null,
  wasmPromise: null,
  wasmPromiseFn: null
};
exports.__bridge = __bridge;

function withWasm(fn) {
  return function () {
    (0, _util.assert)(__bridge.wasm, 'The WASM interface has not been initialized. Ensure that you wait for the initialization Promise with waitReady() from @polkadot/wasm-crypto (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.');

    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }

    return fn(__bridge.wasm, ...params);
  };
}

function getWasm() {
  return __bridge.wasm;
}

function getInt32() {
  if (__bridge.cachegetInt32 === null || __bridge.cachegetInt32.buffer !== __bridge.wasm.memory.buffer) {
    __bridge.cachegetInt32 = new Int32Array(__bridge.wasm.memory.buffer);
  }

  return __bridge.cachegetInt32;
}

function getUint8() {
  if (__bridge.cachegetUint8 === null || __bridge.cachegetUint8.buffer !== __bridge.wasm.memory.buffer) {
    __bridge.cachegetUint8 = new Uint8Array(__bridge.wasm.memory.buffer);
  }

  return __bridge.cachegetUint8;
}

function getU8a(ptr, len) {
  return getUint8().subarray(ptr / 1, ptr / 1 + len);
}

function getString(ptr, len) {
  return (0, _util.u8aToString)(getU8a(ptr, len));
}

function allocU8a(arg) {
  const ptr = __bridge.wasm.__wbindgen_malloc(arg.length * 1);

  getUint8().set(arg, ptr / 1);
  return [ptr, arg.length];
}

function allocString(arg) {
  return allocU8a((0, _util.stringToU8a)(arg));
}

function resultU8a() {
  const r0 = getInt32()[8 / 4 + 0];
  const r1 = getInt32()[8 / 4 + 1];
  const ret = getU8a(r0, r1).slice();

  __bridge.wasm.__wbindgen_free(r0, r1 * 1);

  return ret;
}

function resultString() {
  return (0, _util.u8aToString)(resultU8a());
}