import { AlreadyDestroyedError, CrashError, JsonRpcDisabledError, } from "./types.js";
import { getSpec } from "./specs/index.js";
const listeners = new Map();
if (typeof window === "object") {
    window.addEventListener("message", ({ data }) => {
        var _a;
        if ((data === null || data === void 0 ? void 0 : data.origin) !== "substrate-connect-extension")
            return;
        (_a = listeners.get(data.chainId)) === null || _a === void 0 ? void 0 : _a(data);
    });
}
function getRandomChainId() {
    const arr = new BigUint64Array(2);
    // It can only be used from the browser, so this is fine.
    crypto.getRandomValues(arr);
    const result = (arr[1] << BigInt(64)) | arr[0];
    return result.toString(36);
}
/**
 * Returns a {@link ScClient} that connects to chains by asking the substrate-connect extension
 * to do so.
 *
 * This function assumes that the extension is installed and available. It is out of scope of this
 * function to detect whether this is the case.
 * If you try to add a chain without the extension installed, nothing will happen and the
 * `Promise`s will never resolve.
 */
export const createScClient = () => {
    const chains = new Map();
    const internalAddChain = async (isWellKnown, chainSpecOrWellKnownName, jsonRpcCallback, potentialRelayChainIds = []) => {
        const chainId = getRandomChainId();
        const postToExtension = (msg) => {
            window.postMessage({
                ...msg,
                origin: "substrate-connect-client",
                chainId,
            }, "*");
        };
        const createChain = (msg) => new Promise((res, rej) => {
            listeners.set(chainId, (msg) => {
                listeners.delete(chainId);
                if (msg.type === "chain-ready")
                    return res();
                const errMsg = msg.type === "error"
                    ? msg.errorMessage
                    : "Unexpected message from the extension";
                rej(new Error("There was an error creating the smoldot chain: " + errMsg));
            });
            postToExtension(msg);
        });
        try {
            await createChain(isWellKnown
                ? {
                    type: "add-well-known-chain",
                    chainName: chainSpecOrWellKnownName,
                }
                : {
                    type: "add-chain",
                    chainSpec: chainSpecOrWellKnownName,
                    potentialRelayChainIds,
                });
        }
        catch (e) {
            if (!isWellKnown)
                throw e;
            const chainSpec = await getSpec(chainSpecOrWellKnownName);
            await createChain({
                type: "add-chain",
                chainSpec,
                potentialRelayChainIds: [],
            });
        }
        const chain = {
            sendJsonRpc: (jsonRpcMessage) => {
                if (crashError)
                    throw crashError;
                if (!chains.has(chain))
                    throw new AlreadyDestroyedError();
                if (!jsonRpcCallback)
                    throw new JsonRpcDisabledError();
                postToExtension({ type: "rpc", jsonRpcMessage });
            },
            remove: () => {
                if (crashError)
                    throw crashError;
                if (!chains.has(chain))
                    throw new AlreadyDestroyedError();
                listeners.delete(chainId);
                chains.delete(chain);
                postToExtension({ type: "remove-chain" });
            },
        };
        chains.set(chain, chainId);
        let crashError = null;
        listeners.set(chainId, (msg) => {
            if (msg.type !== "rpc" || !jsonRpcCallback) {
                chain.remove();
                crashError = new CrashError(msg.type === "error"
                    ? msg.errorMessage
                    : "Unexpected message received from the Extension");
                return;
            }
            jsonRpcCallback(msg.jsonRpcMessage);
        });
        return chain;
    };
    return {
        addChain: (chainSpec, jsonRpcCallback) => internalAddChain(false, chainSpec, jsonRpcCallback, [...chains.values()]),
        addWellKnownChain: (name, jsonRpcCallback) => internalAddChain(true, name, jsonRpcCallback),
    };
};
//# sourceMappingURL=extension.js.map