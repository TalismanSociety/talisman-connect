"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._getIds = _getIds;
exports.all = all;
exports.get = get;

var _rxjs = require("rxjs");

var _util = require("@polkadot/util");

var _util2 = require("../util");

// Copyright 2017-2022 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function orderBags(ids, bags) {
  const sorted = ids.map((id, index) => ({
    bag: bags[index].unwrapOr(null),
    id,
    key: id.toString()
  })).sort((a, b) => b.id.cmp(a.id)).map((base, index) => ({ ...base,
    bagLower: _util.BN_ZERO,
    bagUpper: base.id,
    index
  }));
  const max = sorted.length - 1;
  return sorted.map((entry, index) => index === max ? entry // We could probably use a .add(BN_ONE) here
  : { ...entry,
    bagLower: sorted[index + 1].bagUpper
  });
}

function _getIds(instanceId, api) {
  return (0, _util2.memo)(instanceId, _ids => {
    const ids = _ids.map(id => (0, _util.bnToBn)(id));

    return ids.length ? (api.query.voterList || api.query.bagsList).listBags.multi(ids).pipe((0, _rxjs.map)(bags => orderBags(ids, bags))) : (0, _rxjs.of)([]);
  });
}

function all(instanceId, api) {
  return (0, _util2.memo)(instanceId, () => (api.query.voterList || api.query.bagsList).listBags.keys().pipe((0, _rxjs.switchMap)(keys => api.derive.bagsList._getIds(keys.map(_ref => {
    let {
      args: [id]
    } = _ref;
    return id;
  }))), (0, _rxjs.map)(list => list.filter(_ref2 => {
    let {
      bag
    } = _ref2;
    return bag;
  }))));
}

function get(instanceId, api) {
  return (0, _util2.memo)(instanceId, id => api.derive.bagsList._getIds([(0, _util.bnToBn)(id)]).pipe((0, _rxjs.map)(bags => bags[0])));
}